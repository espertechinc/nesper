///////////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2006-2015 Esper Team. All rights reserved.                           /
// http://esper.codehaus.org                                                          /
// ---------------------------------------------------------------------------------- /
// The software in this package is published under the terms of the GPL license       /
// a copy of which has been included with this distribution in the license.txt file.  /
///////////////////////////////////////////////////////////////////////////////////////

using System.Reflection;

using com.espertech.esper.common.client.configuration;
using com.espertech.esper.common.client.util;
using com.espertech.esper.common.@internal.support;
using com.espertech.esper.compat;
using com.espertech.esper.compat.concurrency;
using com.espertech.esper.compat.logging;
using com.espertech.esper.compat.threading.locks;
using com.espertech.esper.regressionlib.framework;
using com.espertech.esper.regressionlib.support.multithread;
using com.espertech.esper.regressionlib.support.util;
using com.espertech.esper.runtime.client;
using com.espertech.esper.runtime.client.scopetest;

using NUnit.Framework;

using static com.espertech.esper.regressionlib.support.client.SupportCompileDeployUtil;

namespace com.espertech.esper.regressionlib.suite.multithread
{
    /// <summary>
    ///     Test for multithread-safety and deterministic behavior when using insert-into.
    /// </summary>
    public class MultithreadDeterminismInsertIntoLockConfig : RegressionExecutionPreConfigured
    {
        private static readonly ILog Log = LogManager.GetLogger(MethodBase.GetCurrentMethod().DeclaringType);

        private readonly EPRuntimeProvider _runtimeProvider = new EPRuntimeProvider();
        private readonly Configuration _configuration;

        public MultithreadDeterminismInsertIntoLockConfig(Configuration configuration)
        {
            _configuration = configuration;
        }

        public void Run()
        {
            TrySendCountFollowedBy(4, 100, Locking.SUSPEND, _configuration);
            TrySendCountFollowedBy(4, 100, Locking.SPIN, _configuration);
        }

        private void TrySendCountFollowedBy(
            int numThreads,
            int numEvents,
            Locking locking,
            Configuration configuration)
        {
            configuration.Runtime.Threading.InsertIntoDispatchLocking = locking;
            configuration.Runtime.Threading.InsertIntoDispatchTimeout = 5000; // 5 second timeout
            configuration.Common.AddEventType(typeof(SupportBean));

            // This should fail all test in this class
            // config.getEngineDefaults().getThreading().setInsertIntoDispatchPreserveOrder(false);
            var runtime = _runtimeProvider.GetRuntimeInstance(
                nameof(MultithreadDeterminismInsertIntoLockConfig),
                configuration);
            runtime.Initialize();

            // setup statements
            var path = new RegressionPath();
            var eplInsert = "@public insert into MyStream select count(*) as cnt from SupportBean";
            var compiledInsert = Compile(eplInsert, configuration, path);
            path.Add(compiledInsert);
            var deployedInsert = Deploy(compiledInsert, runtime);
            deployedInsert.Statements[0].Events += (
                sender,
                updateEventArgs) => {
                Log.Debug(".update cnt=" + updateEventArgs.NewEvents[0].Get("cnt"));
            };

            var listeners = new SupportUpdateListener[numEvents];
            for (var i = 0; i < numEvents; i++) {
                var text = "select * from pattern [MyStream(cnt=" + (i + 1) + ") -> MyStream(cnt=" + (i + 2) + ")]";
                var compiled = Compile(text, configuration, path);
                var deployedPattern = Deploy(compiled, runtime);
                listeners[i] = new SupportUpdateListener();
                deployedPattern.Statements[0].AddListener(listeners[i]);
            }

            // execute
            var threadPool = Executors.NewFixedThreadPool(
                numThreads,
                new SupportThreadFactory(typeof(MultithreadDeterminismInsertIntoLockConfig)).ThreadFactory);
            var future = new IFuture<object>[numThreads];
            var sharedStartLock = new SlimReaderWriterLock();
            using (sharedStartLock.WriteLock.Acquire()) {
                for (var i = 0; i < numThreads; i++) {
                    future[i] = threadPool.Submit(
                        new SendEventRWLockCallable(i, sharedStartLock, runtime, new GeneratorEnumerator(numEvents)));
                }

                ThreadSleep(100);
            }

            threadPool.Shutdown();
            ExecutorAwait(threadPool, 10, TimeUnit.SECONDS);
            AssertFutures(future);

            // assert result
            for (var i = 0; i < numEvents - 1; i++) {
                Assert.AreEqual(1, listeners[i].NewDataList.Count, "Listener not invoked: #" + i);
            }

            runtime.Destroy();
        }
    }
} // end of namespace